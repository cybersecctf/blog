
<!DOCTYPE html>
<html>
<body>
    <h1>ECBCBCWTF- cryptohack</h1>
    <h2>Challenge Description</h2>
    <p> ECB is the most simple mode, with each plaintext block encrypted entirely independently. In this case, your input is prepended to the secret flag and encrypted and that's it. We don't even provide a decrypt function. Perhaps you don't need a padding oracle when you have an "ECB oracle"?

Play at <a href="https://aes.cryptohack.org/ecb_oracle">https://aes.cryptohack.org/ecb_oracle</a>
</p>
    <h2>Solution Approach</h2>
    <p>Here are the steps we took to solve the challenge:</p>
    <ol>
In this challenge encryption is done using AES-128-CBC mode. In this mode the first block is XORed with the IV and then encrypted. The next block is XORed with the previous block and then encrypted. For decryption they use AES-128-ECB mode.
Assume a block of plaintext pi each of size 16 and IV as the initialisation vector. The first block of ciphertext ci is generated by ci = AES(pi ^ IV). The second block of ciphertext ci+1 is generated by ci+1 = AES(pi+1 ^ ci). So we can say that pi+1 = AES-1(ci+1) ^ ci. So to decrypt the flag we can simply decrypt the ciphertext using AES-128-ECB and then XOR the ith decrypted block with the (i-1)th encrypted block. Refer to the following code for better understanding.
<pre>
from Crypto.Cipher import AES
from pwn import xor
import requests
def encrypt():
    url = "http://aes.cryptohack.org//ecbcbcwtf/encrypt_flag/"
    response = requests.get(url)
    return response.json()['ciphertext']
def decrypt(data):
    url = "http://aes.cryptohack.org/ecbcbcwtf/decrypt/"
    response = requests.get(url + data + '/')
    return response.json()['plaintext']
def solvecrypto(data):
 flag = encrypt()
 f = [flag[i:i+32] for i in [0,32,64]]
 vi = f[0:(len(f)-1)]
 f = f[1:]
 for i in range(len(f)):
    f[i] = decrypt(f[i])
 for i in range(len(f)):
    f[i] = xor(bytes.fromhex(f[i]),bytes.fromhex(vi[i]))
 flag = ""
 for i in f:
    flag += i.decode()
 return flag 
def solve(data,key,operation=""):
    # Your provided ciphertext
    if operation=="cryptohack":
         return solvecrypto(data)
         return
    ciphertext = bytes.fromhex(data)
    # Initialization vector and ciphertext blocks
    iv = ciphertext[:16]
    c1 = ciphertext[16:32]
    c2 = ciphertext[32:]
    # Decrypt the blocks
    d1 = decrypted(c1, key)
    d2 = decrypted(c2, key)
    # XOR the decrypted blocks with the previous ciphertext block to get the plaintext
    flag1 = long_to_bytes(bytes_to_long(d1) ^ bytes_to_long(iv))
    flag2 = long_to_bytes(bytes_to_long(d2) ^ bytes_to_long(c1))
    # Combine the plaintext blocks
    flag = flag1 + flag2
    return flag
def decrypt(data):
    url = "http://aes.cryptohack.org/ecbcbcwtf/decrypt/"
    response = requests.get(url + data + '/')
    return response.json()['plaintext']
# Example usage:data from cryptohack
if __name__ == "__main__" :
 data = "d7a86a611700f8cba208533e232082075c6efa40e818dd5b2366982ee2f61c722b2ad5032e96c2e163436e220a03eee9"
 decrypted_data = solve(data,"","cryptohack")
 print(decrypted_data)
</pre>        
       
    
    </ol>
<br>
    <h2>Flag</h2>
    <p class="flag">crypto{3cb_5uck5_4v01d_17_!!!!!}

</p>

    <h2>Conclusion</h2>
    <p>this is a very   easy chanllenge for work on develper tools in in chrome and web exploitations</p>
</body>
</html>


